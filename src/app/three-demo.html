<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Galaxy — no∅ × Three.js</title>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;600;700&family=Outfit:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/novoid.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { overflow: hidden; background: #000; height: 100%; }
    canvas { display: block; }

    .hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      padding: 20px 28px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .hud > * { pointer-events: auto; }

    .hud-title {
      font-family: var(--nv-font-display);
      font-weight: 800;
      font-size: 1.4rem;
      color: #fff;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 20px rgba(0,0,0,0.5);
    }

    .hud-sub {
      font-family: var(--nv-font-sans);
      font-size: 0.75rem;
      color: rgba(255,255,255,0.45);
      margin-top: 4px;
      font-weight: 400;
    }

    .hud-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-end;
    }

    .ctrl-row {
      display: flex;
      gap: 6px;
    }

    .ctrl-btn {
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.7);
      font-family: var(--nv-font-sans);
      font-size: 0.7rem;
      font-weight: 600;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .ctrl-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
      border-color: rgba(255,255,255,0.25);
    }

    .ctrl-btn.active {
      background: rgba(92, 124, 250, 0.3);
      border-color: rgba(92, 124, 250, 0.5);
      color: #a4b8ff;
    }

    .stats {
      position: fixed;
      bottom: 20px;
      left: 28px;
      font-family: var(--nv-font-mono);
      font-size: 0.65rem;
      color: rgba(255,255,255,0.3);
      line-height: 1.8;
      pointer-events: none;
      z-index: 10;
    }

    .stats span { color: rgba(255,255,255,0.55); }

    .hint {
      position: fixed;
      bottom: 20px;
      right: 28px;
      font-family: var(--nv-font-sans);
      font-size: 0.7rem;
      color: rgba(255,255,255,0.25);
      text-align: right;
      pointer-events: none;
      z-index: 10;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 6px 12px;
    }

    .slider-group label {
      font-family: var(--nv-font-sans);
      font-size: 0.65rem;
      font-weight: 600;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      min-width: 50px;
    }

    .slider-group input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.15);
      border-radius: 2px;
      outline: none;
    }

    .slider-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #5c7cfa;
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.3);
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div>
      <div class="hud-title">Particle Galaxy</div>
      <div class="hud-sub">no∅ × Three.js</div>
    </div>
    <div class="hud-controls">
      <div class="ctrl-row">
        <button class="ctrl-btn active" id="btn-galaxy">Galaxy</button>
        <button class="ctrl-btn" id="btn-vortex">Vortex</button>
        <button class="ctrl-btn" id="btn-explosion">Big Bang</button>
        <button class="ctrl-btn" id="btn-wave">Wave</button>
      </div>
      <div class="ctrl-row">
        <div class="slider-group">
          <label>Speed</label>
          <input type="range" id="speed-slider" min="0" max="200" value="100">
        </div>
        <div class="slider-group">
          <label>Trails</label>
          <input type="range" id="trail-slider" min="0" max="100" value="30">
        </div>
      </div>
    </div>
  </div>

  <div class="stats" id="stats"></div>
  <div class="hint">Click & drag to orbit · Scroll to zoom</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ─── config ───
    const PARTICLE_COUNT = 80000;
    const CORE_COUNT = 2000;

    let mode = 'galaxy';
    let speedMult = 1.0;
    let trailOpacity = 0.3;

    // ─── scene setup ───
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('app').appendChild(renderer.domElement);

    // ─── controls ───
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 200;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;

    // ─── post-processing ───
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloom = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      1.5, 0.4, 0.85
    );
    bloom.threshold = 0.1;
    bloom.strength = 1.8;
    bloom.radius = 0.6;
    composer.addPass(bloom);

    // ─── particles ───
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const sizes = new Float32Array(PARTICLE_COUNT);
    const velocities = new Float32Array(PARTICLE_COUNT * 3);
    const origPositions = new Float32Array(PARTICLE_COUNT * 3);

    // Color palettes
    const palettes = {
      galaxy: [
        new THREE.Color(0x5c7cfa), // indigo
        new THREE.Color(0x748ffc), // light indigo
        new THREE.Color(0xbe4bdb), // violet
        new THREE.Color(0x7950f2), // grape
        new THREE.Color(0x339af0), // blue
        new THREE.Color(0xffffff), // white core
      ],
      vortex: [
        new THREE.Color(0x40c057), // green
        new THREE.Color(0x20c997), // teal
        new THREE.Color(0x339af0), // blue
        new THREE.Color(0x5c7cfa), // indigo
        new THREE.Color(0xcc5de8), // violet
      ],
      explosion: [
        new THREE.Color(0xfa5252), // red
        new THREE.Color(0xfd7e14), // orange
        new THREE.Color(0xfab005), // yellow
        new THREE.Color(0xffffff), // white
        new THREE.Color(0xff6b6b), // salmon
      ],
      wave: [
        new THREE.Color(0x22b8cf), // cyan
        new THREE.Color(0x15aabf), // dark cyan
        new THREE.Color(0x3bc9db), // light cyan
        new THREE.Color(0x66d9e8), // pale cyan
        new THREE.Color(0xffffff), // white
      ],
    };

    function initGalaxy() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const isCore = i < CORE_COUNT;

        if (isCore) {
          const r = Math.random() * 3;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          positions[i3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.3;
          positions[i3 + 2] = r * Math.cos(phi);
        } else {
          const arm = Math.floor(Math.random() * 3);
          const armAngle = (arm / 3) * Math.PI * 2;
          const dist = 3 + Math.pow(Math.random(), 0.5) * 45;
          const spiral = dist * 0.15;
          const angle = armAngle + spiral;
          const spread = (0.5 + dist * 0.04) * (Math.random() - 0.5) * 2;

          positions[i3] = Math.cos(angle) * dist + spread * Math.cos(angle + Math.PI / 2);
          positions[i3 + 1] = (Math.random() - 0.5) * (1 + dist * 0.03);
          positions[i3 + 2] = Math.sin(angle) * dist + spread * Math.sin(angle + Math.PI / 2);
        }

        origPositions[i3] = positions[i3];
        origPositions[i3 + 1] = positions[i3 + 1];
        origPositions[i3 + 2] = positions[i3 + 2];

        velocities[i3] = 0;
        velocities[i3 + 1] = 0;
        velocities[i3 + 2] = 0;

        const palette = palettes.galaxy;
        const col = isCore ? palette[5] : palette[Math.floor(Math.random() * 5)];
        const brightness = isCore ? 1.5 : (0.4 + Math.random() * 0.6);
        colors[i3] = col.r * brightness;
        colors[i3 + 1] = col.g * brightness;
        colors[i3 + 2] = col.b * brightness;

        sizes[i] = isCore ? (1.5 + Math.random() * 2) : (0.3 + Math.random() * 1.5);
      }
    }

    function setColors(paletteName) {
      const palette = palettes[paletteName];
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const isCore = i < CORE_COUNT;
        const col = isCore ? palette[palette.length - 1] : palette[Math.floor(Math.random() * (palette.length - 1))];
        const brightness = isCore ? 1.5 : (0.4 + Math.random() * 0.6);
        colors[i3] = col.r * brightness;
        colors[i3 + 1] = col.g * brightness;
        colors[i3 + 2] = col.b * brightness;
      }
      geometry.attributes.color.needsUpdate = true;
    }

    initGalaxy();

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Custom shader material
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uPixelRatio: { value: Math.min(devicePixelRatio, 2) },
      },
      vertexShader: `
        attribute float size;
        varying vec3 vColor;
        uniform float uTime;
        uniform float uPixelRatio;

        void main() {
          vColor = color;
          vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * uPixelRatio * (80.0 / -mvPos.z);
          gl_PointSize = max(gl_PointSize, 0.5);
          gl_Position = projectionMatrix * mvPos;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;

        void main() {
          float d = length(gl_PointCoord - 0.5) * 2.0;
          if (d > 1.0) discard;
          float alpha = 1.0 - smoothstep(0.0, 1.0, d);
          alpha = pow(alpha, 1.5);
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true,
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // ─── ambient dust ───
    const dustGeo = new THREE.BufferGeometry();
    const dustCount = 3000;
    const dustPos = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
      dustPos[i * 3] = (Math.random() - 0.5) * 300;
      dustPos[i * 3 + 1] = (Math.random() - 0.5) * 300;
      dustPos[i * 3 + 2] = (Math.random() - 0.5) * 300;
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({
      size: 0.2,
      color: 0x444466,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    scene.add(new THREE.Points(dustGeo, dustMat));

    // ─── mode behaviors ───
    const clock = new THREE.Clock();
    let elapsed = 0;
    let transitionProgress = 0;
    let transitioning = false;

    function animateGalaxy(dt) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const x = positions[i3];
        const z = positions[i3 + 2];
        const dist = Math.sqrt(x * x + z * z) + 0.01;
        const angularSpeed = (0.3 / (dist * 0.1 + 1)) * speedMult;
        const angle = angularSpeed * dt;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        positions[i3] = x * cos - z * sin;
        positions[i3 + 2] = x * sin + z * cos;
        positions[i3 + 1] += (origPositions[i3 + 1] - positions[i3 + 1]) * 0.02;
      }
    }

    function animateVortex(dt) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const x = positions[i3];
        const y = positions[i3 + 1];
        const z = positions[i3 + 2];
        const dist = Math.sqrt(x * x + z * z) + 0.01;
        const angularSpeed = (1.5 / (dist * 0.05 + 1)) * speedMult;
        const angle = angularSpeed * dt;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        positions[i3] = x * cos - z * sin;
        positions[i3 + 2] = x * sin + z * cos;

        // Lift to vortex funnel
        const targetY = dist * 0.6 - 15;
        positions[i3 + 1] += (targetY - y) * 0.01;

        // Pull inward
        const pullStrength = 0.001 * speedMult;
        positions[i3] -= (x / dist) * pullStrength;
        positions[i3 + 2] -= (z / dist) * pullStrength;

        // Push out if too close
        if (dist < 2) {
          positions[i3] += (x / dist) * 0.05;
          positions[i3 + 2] += (z / dist) * 0.05;
        }
      }
    }

    function animateExplosion(dt) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        positions[i3] += velocities[i3] * dt * speedMult;
        positions[i3 + 1] += velocities[i3 + 1] * dt * speedMult;
        positions[i3 + 2] += velocities[i3 + 2] * dt * speedMult;

        // Slight gravity pull back
        const x = positions[i3], y = positions[i3 + 1], z = positions[i3 + 2];
        const dist = Math.sqrt(x * x + y * y + z * z) + 0.1;
        const grav = 0.3 / (dist + 1);
        velocities[i3] -= (x / dist) * grav * dt;
        velocities[i3 + 1] -= (y / dist) * grav * dt;
        velocities[i3 + 2] -= (z / dist) * grav * dt;

        // Damping
        velocities[i3] *= 0.999;
        velocities[i3 + 1] *= 0.999;
        velocities[i3 + 2] *= 0.999;
      }
    }

    function animateWave(dt) {
      const t = elapsed * speedMult;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        const ox = origPositions[i3];
        const oz = origPositions[i3 + 2];
        const dist = Math.sqrt(ox * ox + oz * oz);
        const waveHeight = Math.sin(dist * 0.2 - t * 2) * 3 + Math.sin(dist * 0.1 + t * 1.3) * 2;

        positions[i3] += (ox - positions[i3]) * 0.02;
        positions[i3 + 1] += (waveHeight - positions[i3 + 1]) * 0.05;
        positions[i3 + 2] += (oz - positions[i3 + 2]) * 0.02;
      }
    }

    function triggerExplosion() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        // Reset to center-ish
        positions[i3] = (Math.random() - 0.5) * 2;
        positions[i3 + 1] = (Math.random() - 0.5) * 2;
        positions[i3 + 2] = (Math.random() - 0.5) * 2;

        // Outward velocity
        const speed = 5 + Math.random() * 40;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        velocities[i3] = Math.sin(phi) * Math.cos(theta) * speed;
        velocities[i3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
        velocities[i3 + 2] = Math.cos(phi) * speed;
      }
    }

    function setMode(newMode) {
      mode = newMode;
      setColors(newMode);
      if (newMode === 'explosion') triggerExplosion();

      document.querySelectorAll('.ctrl-btn[id^="btn-"]').forEach(b => b.classList.remove('active'));
      document.getElementById('btn-' + newMode).classList.add('active');

      if (newMode === 'vortex') {
        bloom.strength = 2.2;
      } else if (newMode === 'explosion') {
        bloom.strength = 2.5;
      } else {
        bloom.strength = 1.8;
      }
    }

    // ─── controls wiring ───
    document.getElementById('btn-galaxy').onclick = () => setMode('galaxy');
    document.getElementById('btn-vortex').onclick = () => setMode('vortex');
    document.getElementById('btn-explosion').onclick = () => setMode('explosion');
    document.getElementById('btn-wave').onclick = () => setMode('wave');

    document.getElementById('speed-slider').oninput = (e) => {
      speedMult = e.target.value / 100;
    };

    document.getElementById('trail-slider').oninput = (e) => {
      trailOpacity = e.target.value / 100;
      bloom.strength = 1.0 + trailOpacity * 3;
    };

    // ─── stats ───
    const statsEl = document.getElementById('stats');
    let frameCount = 0;
    let fpsTime = 0;
    let fps = 60;

    // ─── animation loop ───
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      elapsed += dt;

      material.uniforms.uTime.value = elapsed;

      switch (mode) {
        case 'galaxy': animateGalaxy(dt); break;
        case 'vortex': animateVortex(dt); break;
        case 'explosion': animateExplosion(dt); break;
        case 'wave': animateWave(dt); break;
      }

      geometry.attributes.position.needsUpdate = true;

      controls.update();
      composer.render();

      // FPS counter
      frameCount++;
      fpsTime += dt;
      if (fpsTime >= 0.5) {
        fps = Math.round(frameCount / fpsTime);
        frameCount = 0;
        fpsTime = 0;
        statsEl.innerHTML =
          `<span>${PARTICLE_COUNT.toLocaleString()}</span> particles · ` +
          `<span>${fps}</span> fps · ` +
          `<span>${mode}</span> mode`;
      }
    }

    animate();

    // ─── resize ───
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      material.uniforms.uPixelRatio.value = Math.min(devicePixelRatio, 2);
    });
  </script>
</body>
</html>